\section{System Architecture and Threat Model}

In this section, we first briefly describe \sensorname, the basis of \blurname.
Then we discuss the new extensions to \sensorname for enabling \blurname through
defining a threat model.

\subsection{Building \sensorname}

The prerequisite of \blurname is to gain access to sensor data. However,
different devices and platforms, such as Android and iOS, use very different
interfaces into their sensors. One of the major goals of our testbed is to
support a wide range of sensor categories, broader device and network diversity,
while the client software still behave in a portable manner.  

\subsubsection{Seattle Porting onto Mobile Devices}\label{sec-portability}
Seattle is the testbed platform we have developed over the past four
years~\cite{Seattlewebpage}. It supports a wide range of devices including
desktop, laptop, servers, etc. We recently ported Seattle onto mobile platforms.

Compared to desktop and laptop environments, development on mobile platforms has
more difficulties and restrictions due to the inherent resource limitations,
such as limited computational power and battery levels. 
However, researchers were able to do early stage ports 
of Seattle to Android~\cite{seattleonandroid} (and jailbroken iPad / iPhone / 
iPod) with a few weeks of developer effort. Users can now download a 
native Android installer (APK) from the Google Play 
store~\cite{seattle-android}. Our Seattle testbed on Android supports Android 
versions from 2.1 to 4.0.4 (API levels 7 to 15), covering device versions with 
the highest market distribution~\cite{dashboard-android}.   
Despite never being advertised or mentioned publicly, our Seattle 
app in Google Play has more than 50 installs.   
% While not yet a production-ready release, the proof-of-concept implementations
% on Android, iPad, iPhone, and OpenWRT home wireless routers, demonstrate
% this is a feasible, low-risk effort.

\subsubsection{Supporting Sensors on Mobile Devices}

Due to the isolation of the VM in Seattle, a researcher cannot normally access
sensors on a user's mobile device, such as GPS, WiFi SSID and signal strength,
motion sensors (e.g., accelerometer, compass, gyroscope, barometer), etc.
However, many users would like a way to provide information about these sensors
to selected researchers. To facilitate the exchange of information, we provide a
set of API that reads sensor data from a Seattle VM for researchers trusted by
the user. This API framework is \sensorname. 

\sensorname is a generic sensor reading framework built on top of Seattle on
Android. It funnels data from actual sensor drivers, implements fine-grained
privacy control for the user, and provides generic outbound interfaces such as
XML-RPC. However, the APIs provided by native smartphone sensors vary
significantly across platforms. Our philosophy is to provide a simple API that  
would allow a variety of sensor applications to operate in a unified manner.

First, we implemented system hooks called {\it sensor modules} to interact with
a variety of sensors through system programming interfaces. Currently,
implemented sensor modules and the available contextual information are
classified into three categories: device specific (percentage of battery power
level, CPU and memory utility), location related (latitude, longitude, altitude,
accuracy, and speed if available), and network related (mobile network type and
operator, nearby WiFi access point and Bluetooth devices). While sensor modules
are the system hooks with read access to valuable sensor resources, they cannot
manipulate sensor data. Additionally, the sensor API also provides a base {\it
registry service} with a common interface which each sensor implementation can
easily be plugged into.  For both local and remote processes to access sensor
data, an XML-RPC library~\cite{xmlrpc-android} is incorporated to provide data
in an unified format. In case newer sensors appear on future mobile devices,
developers can add newly implemented sensors into this framework rather easily.
The registry service listens for connection on a set of predefined ports via
XML-RPC. Thus, both local and remote process can connect to these ports and
register for sensor updates. 

Our preliminary work in this area has resulted in working 
code~\cite{seattle-sensor-git}, tutorials~\cite{seattle-sensor-project}, and a 
blog for problem discussion~\cite{sensor}. Several different groups have
already used our early-stage proof-of-concept to solve problems across a variety
of domains, demonstrating the potential of sharing sensor data. 

\subsection{\blurname Threat Model}\label{sec-threat}

While sensors on smartphones are a powerful tool for researchers, they also pose
a risk to users. A study showed that unscrupulous hackers typically find
personal information stored on devices inviting~\cite{mulligan2000your}. There
has been alarming news about privacy breaches of personal data on smart devices:
26\% of Android apps in Google Play can access user's personal
data~\cite{toomuch}; an iOS app auto-posts false piracy accusations on users'
Twitter accounts~\cite{tweetios}; apps can steal sensitive information like
passwords using the smartphone's motion sensors to determine tapped
keys~\cite{xu2012taplogger}; and a huge botnet that is collecting sensor data
was discovered on more than a million end user smartphones~\cite{botnet}. The
Federal Trade Commission (FTC) recently recommended that mobile platforms should
provide in-time disclosures to users of accessing sensitive content on smart
devices~\cite{ftc}. However, the current privacy mechanisms are rather limited,
and most privacy controls are one-size-fits-all: the user either opts-in or
cannot use the site or application. Therefore, care must be taken when sharing
data on smartphones and similar devices. And there is a need to control the
access of third party in a consistent but also dynamic, fine-grained manner.
\yanyan{perhaps shorten this.}

To further motivate our work, we consider three cases in our threat model. The
first category under consideration is called \textbf{ambitious legitimate
applications}. In this category, the developers of the applications ask for more
permissions than needed in the manifest file, e.g., for profit purpose. For
example, the applications run some hidden code, connecting to remote
advertisement servers, which analyze smartphone users' characters based on their
behavioral patterns. The servers will then send these users advertisements
that they might be interested in, to increase the income of those companies who
posted the advertisements.

The second category is called \textbf{compromised legitimate applications}. In
this category, the legitimate applications have some vulnerabilities, such as
buffer overflow, so these legitimate applications are actually under the full
control of remote attackers. The attackers might bypass the first defensive line
and collect sensitive information about the users, such as contacts, credit card
numbers, and passwords, to jeopardize users’ privacy.

The third category is called \textbf{malicious applications}. These applications
are designed by attackers with malicious purposes. They behave like benign ones,
but in fact, they covertly collect users’ private information, like trojans.

In the following section, we introduce our proposed scheme that is able to
detect and defend against all these three types of threats above.