"""
Steven Portzer
Start Date: 08/13/2012

Purpose: To log the output generated by modeling a set of traces.

"""

import model_network_syscalls as model
from ip_matching import format_addr
from ip_matching import addr_dont_care
from ip_matching import is_addr_match



##### Model Configuration #####

# Inspect the send and receive calls made within traces to better match
# up TCP connections.
ENABLE_TCP_DATA_MATCHING = True



##### Output Level Configuration #####

# Print system calls that raise warnings even if SHOW_SYSCALLS is False
SHOW_WARNINGS = True

# Print system calls that raise notices even if SHOW_SYSCALLS is False
SHOW_NOTICES = False

# Print all system calls except possibly those that raise don't care
SHOW_SYSCALLS = False

# Don't print system calls we don't care about
SUPPRESS_DONTCARE = False

# Don't print failed attempts of system calls (calls that cause the
# model to raise an error and must be reattempted later)
SUPPRESS_ATTEMPTS = False


# If not None, only print this many characters of sent/received strings
MAX_STRING_LEN = 32


# Print all the details of the model's state once verificantion finishes
PRINT_MODEL_STATE = False

# Print general statistics on the amount of data sent/received
PRINT_STATISTICS = True

######################################



# System calls that received data over the network.
RECV_SYSCALLS = [
  "recv_syscall", "recvfrom_syscall", "recvmsg_syscall", "read_syscall"
]

# System calls that send data over the network.
SEND_SYSCALLS = [
  "send_syscall", "sendto_syscall", "sendmsg_syscall", "sendfile_syscall",
  "write_syscall", "writev_syscall"
]



# Exceptions that occur during execution of the traces.
exception_list = []

# Ignored connect calls
dontcare_connect_list = []

# Ignored accept calls
dontcare_accept_list = []

# Maps sockets to the number of time that socket tried to write and got EPIPE or ECONNRESET
send_after_closed_dict = {}

# A dict of booleans specifying which traces have had network traffic we care about
trace_has_traffic = {}

# A dict of booleans specifying which traces have had network traffic we don't care about
has_dontcare_traffic = {}



def log_intialize(trace_ids):

  for trace_id in trace_ids:
    trace_has_traffic[trace_id] = False
    has_dontcare_traffic[trace_id] = False

  print "-" * 80
  print "Verifying Traces"
  print "-" * 80


def log_syscall(syscall, err=None):

  name, args, ret = syscall
  trace_id = args[0]

  sock = None
  if name in RECV_SYSCALLS or name in SEND_SYSCALLS or \
      name == "accept_syscall" or name == "connect_syscall":
    if args[:2] in model.sockets:
      sock = model.sockets[args[:2]]

  if err is None:
    if SHOW_SYSCALLS:
      print "trace", str(trace_id) + ":", shorten_syscall(syscall)

    if sock and (name != "connect_syscall" or sock['protocol'] == model.IPPROTO_TCP):
      trace_has_traffic[trace_id] = True

    if name in SEND_SYSCALLS and (ret == (-1, 'EPIPE') or ret == (-1, 'ECONNRESET')):
      send_after_closed_dict.setdefault(args[:2], 0)
      send_after_closed_dict[args[:2]] += 1

  elif isinstance(err, model.SyscallDontCare):
    if name == 'connect_syscall':
      dontcare_connect_list.append(syscall)
    elif name == 'accept_syscall':
      dontcare_accept_list.append(syscall)

    if sock and (name != "connect_syscall" or sock['protocol'] == model.IPPROTO_TCP):
      has_dontcare_traffic[trace_id] = True

    if SHOW_SYSCALLS and not SUPPRESS_DONTCARE:
      print "[Don't Care] trace", str(trace_id) + ":", shorten_syscall(syscall)

  elif isinstance(err, model.SyscallNotice):
    if SHOW_SYSCALLS or SHOW_NOTICES:
      print "[Notice] trace", str(trace_id) + ":", shorten_syscall(syscall)
      print "   => %s: %s" % err.args[1:]
    exception_list.append((syscall, err))

  elif isinstance(err, model.SyscallWarning):
    if SHOW_SYSCALLS or SHOW_WARNINGS:
      print "[Warning] trace", str(trace_id) + ":", shorten_syscall(syscall)
      print "   => %s: %s" % err.args[1:]
    exception_list.append((syscall, err))

    if err.args[1] == 'EPIPE/ECONNRESET':
      send_after_closed_dict.setdefault(args[:2], 0)
      send_after_closed_dict[args[:2]] += 1

  elif isinstance(err, model.SyscallError):
    print "[Error] trace", str(trace_id) + ":", shorten_syscall(syscall)
    print "   => %s: %s" % err.args[1:]
    exception_list.append((syscall, err))


def log_syscall_attempt(syscall, err):

  if SUPPRESS_ATTEMPTS or not SHOW_SYSCALLS:
    return

  name, args, ret = syscall
  trace_id = args[0]

  print "[Failed to Execute] trace", str(trace_id) + ":", shorten_syscall(syscall)
  print "   => %s: %s" % err.args[1:]


def log_unexpected_success(syscall, model_ret):

  print
  print "Model successfully executed system call but trace contains an error!"
  print "[Error] trace", str(syscall[1][0]) + ":", shorten_syscall(syscall)
  print "   => UNEXPECTED_RETURN_VALUE: Model returned ", model_ret
  exception_list.append((syscall,
      model.SyscallNotice(syscall[0], 'UNEXPECTED_SUCCESS', "Model succeeded but implementation failed")))

  analyze_results(True)


def log_execution_blocked(syscall_list):

  print
  print "No valid action:"
  for syscall, err in syscall_list:
    trace_id = syscall[1][0]
    print "[Error] trace", str(trace_id) + ":", shorten_syscall(syscall)
    print "   => %s: %s" % err.args[1:]
    exception_list.append((syscall, err))

  analyze_results(True)


def log_done():

  print
  print "Done"

  analyze_results(False)



def shorten_syscall(syscall):
  """
  Returns the system call with strings abridged if neccessary.
  """

  name, args, ret = syscall

  if name == 'send_syscall':
    trace_id, sock, msg, flag = args
    args = trace_id, sock, shorten_string(msg), flag

  elif name == 'write_syscall':
    trace_id, sock, msg = args
    args = trace_id, sock, shorten_string(msg)

  elif name == 'writev_syscall':
    trace_id, sock, msg, count = args
    args = trace_id, sock, shorten_string(msg), count

  elif name == 'sendto_syscall':
    trace_id, sock, msg, flags, remoteip, remoteport = args
    args = trace_id, sock, shorten_string(msg), flags, remoteip, remoteport

  elif name == 'sendmsg_syscall':
    trace_id, sock, msg, remoteip, remoteport, flags = args
    args = trace_id, sock, shorten_string(msg), remoteip, remoteport, flags

  elif name == 'recvfrom_syscall':
    trace_id, sock, msg, buf_len, flags, ip, port = args
    args = trace_id, sock, shorten_string(msg), buf_len, flags, ip, port

  elif name == 'recvmsg_syscall':
    trace_id, sock, msg, buf_len, ip, port, flags = args
    args = trace_id, sock, shorten_string(msg), buf_len, ip, port, flags

  elif name == 'recv_syscall':
    trace_id, sock, msg, buf_len, flags = args
    args = trace_id, sock, shorten_string(msg), buf_len, flags

  elif name == 'read_syscall':
    trace_id, sock, msg, buf_len = args
    args = trace_id, sock, shorten_string(msg), buf_len

  return name, args, ret


def shorten_string(string):
  """
  Returns the string, abridged if neccessary.
  """

  if isinstance(string, str) and MAX_STRING_LEN and len(string) > MAX_STRING_LEN:
    return string[:MAX_STRING_LEN] + "..."
  else:
    return string



def analyze_results(parsing_failed):

  errors = []

  if parsing_failed:
    errors.append("The model failed to process the entire trace")

  print_model_state()

  errors += check_possible_nats(parsing_failed)
  errors += check_tcp_buffers()
  errors += check_udp_buffers()
  errors += check_exceptions()

  print
  print "-" * 80
  print "Possible Problems Detected"
  print "-" * 80
  for error in errors:
    print " * " + error

  if not errors:
    print " * None"
  else:
    print
    print "For more details, adjust the variables defined in trace_output.py to change the level of output"



def check_possible_nats(parsing_failed):

  errors = []

  possible_nats = False
  found_something = False
  accept_dict = {}
  connect_dict = {}

  if exception_list:
    last_syscall, last_err = exception_list[-1]
    if last_syscall[0] == 'connect_syscall' and last_err.args[1] == 'UNEXPECTED_SUCCESS':
      bad_fd = last_syscall[1][:2]
      for a_sock in model.pending_connections:
        if bad_fd in model.pending_connections[a_sock]:
          model.pending_connections[a_sock].remove(bad_fd)

  for a_sock in model.pending_connections:
    for c_sock in model.pending_connections[a_sock][:]:
      if model.sockets[c_sock]['state'] != 'CONNECTED':
        model.pending_connections[a_sock].remove(c_sock)

  for name, args, ret in dontcare_accept_list:
    if ret[0] != -1:
      accept_dict.setdefault(args[:2], set()).add(args[2])

  for a_sock in model.pending_connections:
    if model.pending_connections[a_sock]:
      print
      print "-" * 80
      print "Network Configuration Issues"
      print "-" * 80
      found_something = True
      break

  for a_sock in model.pending_connections:
    pending = model.pending_connections[a_sock]
    if not pending:
      continue

    pending_dict = {}
    for sock in pending:
      key = (sock[0], model.sockets[sock]['peer_ip'], model.sockets[sock]['peer_port'])
      pending_dict.setdefault(key, 0)
      pending_dict[key] += 1

    local_addr = format_addr(model.sockets[a_sock]['local_ip'], model.sockets[a_sock]['local_port'])

    print "TCP server socket %s%d" % a_sock, "(private address " + local_addr + ") has",
    print len(pending), "unaccepted connection(s)"
    for trace_id, ip, port in pending_dict:
      print " * There are", pending_dict[(trace_id, ip, port)], "unaccepted connection(s) from trace",
      print trace_id, "to", format_addr(ip, port)

    if a_sock in accept_dict:
      print " * This server socket ignored connections from these IPs:", ", ".join(accept_dict[a_sock])
      print " * The traces whose connections have not been accepted may be behind NATs"
      possible_nats = True
    else:
      errors.append("[Possible Network Misbehavior] Connections intended for the socket in trace " +
           str(a_sock[0]) + " listening on "  + local_addr + " may have been accepted elsewhere")
      if parsing_failed:
        print " * Since the traces could not be fully processed, this alone may not be significant"
      print " * The connecting sockets may have connected to an entirely different server socket"

  ignored_accepts = [syscall for syscall, err in exception_list
                     if err.args[1] == 'NO_PENDING_CONN' and syscall[2][0] != -1]

  if ignored_accepts:
    print
    if not found_something:
      print "-" * 80
      print "Network Configuration Issues"
      print "-" * 80
    possible_nats = True
    found_something = True

  ignored_accept_dict = {}
  for name, args, ret in ignored_accepts:
    ignored_accept_dict.setdefault(args[:2], []).append(args[2])

  for a_sock in ignored_accept_dict:
    local_addr = format_addr(model.sockets[a_sock]['local_ip'], model.sockets[a_sock]['local_port'])
    print "TCP server socket %s%d (private address" % a_sock,
    print local_addr + ") failed to find corresponding connects for",
    print len(ignored_accept_dict[a_sock]), "accept(s)"

    ignored_ip_dict = {}
    for ip in ignored_accept_dict[a_sock]:
      ignored_ip_dict.setdefault(ip, 0)
      ignored_ip_dict[ip] += 1

    for ip in ignored_ip_dict:
      print " * There are", ignored_ip_dict[ip], "unmatched accepts from IP", ip

    print " * Trace", a_sock[0], "may be behind a NAT and port forwarding may be occurring"

  unknown_connect_failures = [syscall for syscall, err in exception_list
                              if err.args[1] == 'UNEXPECTED_FAILURE' and
                                 syscall[0] == 'connect_syscall']

  if unknown_connect_failures:
    print
    if not found_something:
      print "-" * 80
      print "Network Configuration Issues"
      print "-" * 80
    found_something = True
    errors.append("[Possible Network Misbehavior] One or more connects failed with an unknown error. " + \
                  "This may be due to something filtering connection, for example a firewall.")

  unknown_connect_dict = {}
  for name, args, ret in unknown_connect_failures:
    trace, sock, ip, port = args
    connect_tuple = (trace, (ip, port))
    unknown_connect_dict.setdefault(connect_tuple, 0)
    unknown_connect_dict[connect_tuple] += 1

  for trace, connect_addr in unknown_connect_dict:
    print "Trace", trace, "failed to connect to", format_addr(connect_addr[0], connect_addr[1]),
    print unknown_connect_dict[(trace, connect_addr)], "time(s) with an unknown error"
    for a_sock in model.sockets:
      if model.sockets[a_sock]['state'] != 'LISTEN':
        continue
      ip = model.sockets[a_sock]['local_ip']
      port = model.sockets[a_sock]['local_port']
      is_match, warnings = is_addr_match(a_sock[0], (ip, port), trace, connect_addr, True)
      if is_match:
        print "   This address matches server socket %s%d, which was bound to" % a_sock, format_addr(ip, port)
        for warning in warnings:
          print "    * [Warning]", warning

  refused_connect_failures = [syscall for syscall, err in exception_list
                              if err.args[1] == 'ECONNREFUSED' and
                                 syscall[0] == 'connect_syscall']

  if refused_connect_failures:
    print
    if not found_something:
      print "-" * 80
      print "Network Configuration Issues"
      print "-" * 80
    found_something = True

  refused_connect_dict = {}
  for name, args, ret in refused_connect_failures:
    trace, sock, ip, port = args
    connect_tuple = (trace, (ip, port))
    refused_connect_dict.setdefault(connect_tuple, 0)
    refused_connect_dict[connect_tuple] += 1

  refused_issue = False

  for trace, connect_addr in refused_connect_dict:
    print "Trace", trace, "failed to connect to", format_addr(connect_addr[0], connect_addr[1]),
    print refused_connect_dict[(trace, connect_addr)], "time(s) because the connection was refused"
    for a_sock in model.sockets:
      if model.sockets[a_sock]['state'] != 'LISTEN':
        continue
      ip = model.sockets[a_sock]['local_ip']
      port = model.sockets[a_sock]['local_port']
      is_match, warnings = is_addr_match(a_sock[0], (ip, port), trace, connect_addr, True)
      if is_match:
        refused_issue = True
        print "   This address matches server socket %s%d, which was bound to" % a_sock, format_addr(ip, port)
        for warning in warnings:
          print "    * [Warning]", warning

  if refused_issue:
    errors.append("[Ambiguous Misbehavior] One or more connects to addresses that were being listened on failed. " + \
                  "This may be due to the timing of the connect and listen or may be due to a network issue.")

  failed_nonblock_connects = {}

  for sock in model.sockets:
    if model.sockets[sock]['state'] == 'PENDING' and \
        not addr_dont_care(model.sockets[sock]['peer_ip'], model.sockets[sock]['peer_port']):
      connect_tuple = (sock[0], model.sockets[sock]['peer_ip'], model.sockets[sock]['peer_port'])
      failed_nonblock_connects.setdefault(connect_tuple, 0)
      failed_nonblock_connects[connect_tuple] += 1

  if failed_nonblock_connects:
    print
    if not found_something:
      print "-" * 80
      print "Network Configuration Issues"
      print "-" * 80
    found_something = True
    print "Several nonblocking connects may have failed to connect"
    for trace, ip, port in failed_nonblock_connects:
      number = failed_nonblock_connects[(trace, ip, port)]
      print " *", number, "nonblocking connects from trace", trace, "to",
      print format_addr(ip, port), "were never observed to connect"

  no_traffic = [trace_id for trace_id in trace_has_traffic
                if has_dontcare_traffic[trace_id] and not trace_has_traffic[trace_id]]

  if no_traffic and not found_something:
    print
    print "-" * 80
    print "Network Configuration Issues"
    print "-" * 80
    print "These traces have network activity, but do not appear to communicate with other traces:", ", ".join(no_traffic)
    if parsing_failed:
      print " * Since the traces could not be fully processed, this alone may not be significant"
    print " * This may indicate that they are behind a NAT"
    print " * It is also possible that there is a third party acting as a proxy or forwarding traffic"
    possible_nats = True

  if possible_nats:
    errors.append("There may be one or more NATs not declared in the configuration file")
    print
    print "Please check if there are any NATs present which are not explicitly declared in the configuration file"
    print " * If so, add them to configuration file and rerun NetCheck"

  return errors


def check_exceptions():

  unknown_calls = set()
  buffer_size_exceptions = {}
  option_not_handled_exceptions = 0
  overlapping_conns = set()

  connect_failed = []

  for syscall, err in exception_list:
    name, args, ret = syscall
    trace_id = args[0]
    impl_ret, impl_err = ret
    model_err = err.args[1]

    if model_err == 'UNKNOWN_SYSCALL':
      unknown_calls.add(name)
    elif model_err == 'NOT_HANDLE_OPTION' or model_err == 'UNKNOWN_LEVEL':
      option_not_handled_exceptions += 1
    elif model_err == 'MSG_>_BUFSIZE':
      buffer_size_exceptions.setdefault(trace_id, 0)
      buffer_size_exceptions[trace_id] += 1
    elif model_err == 'OVERLAPPING_CONNECTS':
      overlapping_conns.add(trace_id)
    elif model_err == 'UNEXPECTED_SUCCESS':
      if name == 'connect_syscall':
        trace_id, sock, ip, port = args
        connect_failed.append((trace_id, ip, port, impl_err))

  errors = []

  for trace_id in buffer_size_exceptions:
    errors.append("[Possible Network Misbehavior] " + str(buffer_size_exceptions[trace_id]) +
        " different call(s) caused trace " + str(trace_id) + " to exceeded an expected buffer size")

  for trace_id, ip, port, impl_err in connect_failed:
    errors.append("[Possible Network Misbehavior] Trace " + trace_id + " unexpectedly failed to connect to "
         + format_addr(ip, port) + " with the following error: " + impl_err)

  if unknown_calls:
    errors.append("The following call(s) are not currently handled by the model: " + ", ".join(unknown_calls))

  if option_not_handled_exceptions:
    errors.append(str(option_not_handled_exceptions) +
        " call(s) to getsockopt, setsockopt, fcntl, or ioctl used options which are not currently handled")

  if overlapping_conns:
    if len(overlapping_conns) == 1:
      errors.append("Trace " + list(overlapping_conns)[0] +
          " has simultaneously occurring nonblocking connects, which may " +
          "mean that the corresponding accepts are improperly matched")
    else:
      errors.append("Trace(s) " + ", ".join(overlapping_conns) +
          " have simultaneously occurring nonblocking connects, which may " +
          "mean that the corresponding accepts are improperly matched")

  return errors


def check_tcp_buffers():

  for t in model.tcp_tuples:
    if t['accepting_fd'] is not None:
      break
  else:
    return []

  if PRINT_STATISTICS:
    print
    print "-" * 80
    print "TCP Connection Statistics"
    print "-" * 80

  nonempty_connection_dict = {}

  poll_errors = set([syscall[1][:2] for syscall, err in exception_list
                     if (err.args[0] == 'recv_syscall' or err.args[0] == 'send_syscall') and
                        err.args[1].startswith('NETWORK_ERROR')])

  for t in model.tcp_tuples:
    # Connection was never accepted
    if t['accepting_fd'] is None:
      continue 

    connect_sock = model.sockets[t['connected_fd']]
    accept_sock = model.sockets[t['accepting_fd']]
    connect_tuple = (t['connected_fd'][0], connect_sock['peer_ip'], connect_sock['peer_port'])

    if t['c_buffer'][1] != 0 or t['a_buffer'][1] != 0:
      event_tuple = connect_tuple + (t['connected_fd'] in poll_errors or
          t['accepting_fd'] in poll_errors,)
      nonempty_connection_dict.setdefault(event_tuple, 0)
      nonempty_connection_dict[event_tuple] += 1

    if PRINT_STATISTICS:
      print "Connection from socket %s%d (public address" % t['connected_fd'],
      print format_addr(accept_sock['peer_ip'], accept_sock['peer_port']) + ")",
      print "to socket %s%d (public address" % t['accepting_fd'],
      print format_addr(connect_sock['peer_ip'], connect_sock['peer_port']) + ")"

      print " * Data sent to accepting socket %s%d:" % t['accepting_fd'],
      print t['c_buffer'][2], "bytes sent,",
      print t['c_buffer'][2] - t['c_buffer'][1], "bytes received,",
      print t['c_buffer'][1], "bytes lost",
      if t['c_buffer'][1]:
        print "(%.2f%%)" % (100.0 * t['c_buffer'][1] / t['c_buffer'][2]),
      print

      print " * Data sent to connected socket %s%d:" % t['connected_fd'],
      print t['a_buffer'][2], "bytes sent,",
      print t['a_buffer'][2] - t['a_buffer'][1], "bytes received,",
      print t['a_buffer'][1], "bytes lost",
      if t['a_buffer'][1]:
        print "(%.2f%%)" % (100.0 * t['a_buffer'][1] / t['a_buffer'][2]),
      print

      if t['c_buffer'][1] != 0 or t['a_buffer'][1] != 0:
        if t['connected_fd'] in poll_errors or t['accepting_fd'] in poll_errors:
          print " * [Ambiguous Misbehavior] Data loss may be due to network conditions, such as filtering or network delay, but may also be due to delay in application itself"
        else:
          print " * [Possible Application Misbehavior] Data loss is most likely due to application behavior"

      if t['connected_fd'] in send_after_closed_dict:
        print " * [Possible Application Misbehavior] socket %s%d" % t['connected_fd'],
        print "failed to send some data because the connection was closed"

      if t['accepting_fd'] in send_after_closed_dict:
        print " * [Possible Application Misbehavior] socket %s%d" % t['accepting_fd'],
        print "failed to send some data because the connection was closed"

  errors = []

  for trace_id, ip, port, is_ambiguous in nonempty_connection_dict:
    if is_ambiguous:
      errors.append("[Ambiguous Misbehavior] Trace " + trace_id + " has " +
          str(nonempty_connection_dict[(trace_id, ip, port, is_ambiguous)]) + " TCP connection(s) to " +
          format_addr(ip, port) + " with unreceived data not detected by poll or select")
    else:
      errors.append("[Possible Application Misbehavior] Trace " + trace_id + " has " +
          str(nonempty_connection_dict[(trace_id, ip, port, is_ambiguous)]) + " TCP connection(s) to " +
          format_addr(ip, port) + " with data left in the buffers")

  return errors


def check_udp_buffers():

  if not model.udp_tuples:
    return []

  connection_dict = {}

  for t in model.udp_tuples:
    if t['connected_ip']:
      sender = (t['connected_ip'], t['connected_port'])
    else:
      sender = list(t['connected_fd_list'])[0][0]
    receiver = (t['accepting_ip'], t['accepting_port'])
    connect_tuple = (sender, receiver)
    accept_tuple = (receiver, sender)
    if connect_tuple not in connection_dict:
      connection_dict[connect_tuple] = {'sent': 0, 'lost': 0, 'bytes_sent': 0, 'bytes_lost': 0}
    if accept_tuple not in connection_dict:
      connection_dict[accept_tuple] = {'sent': 0, 'lost': 0, 'bytes_sent': 0, 'bytes_lost': 0}

    for m in t['a_dtgrams']:
      connection_dict[accept_tuple]['sent'] += t['a_dtgrams'][m][0]
      connection_dict[accept_tuple]['bytes_sent'] += t['a_dtgrams'][m][0] * len(m)
      unreceived = t['a_dtgrams'][m][0] - t['a_dtgrams'][m][1]
      if unreceived > 0:
        connection_dict[accept_tuple]['lost'] += unreceived
        connection_dict[accept_tuple]['bytes_lost'] += unreceived * len(m)

    for m in t['c_dtgrams']:
      connection_dict[connect_tuple]['sent'] += t['c_dtgrams'][m][0]
      connection_dict[connect_tuple]['bytes_sent'] += t['c_dtgrams'][m][0] * len(m)
      unreceived = t['c_dtgrams'][m][0] - t['c_dtgrams'][m][1]
      if unreceived > 0:
        connection_dict[connect_tuple]['lost'] += unreceived
        connection_dict[connect_tuple]['bytes_lost'] += unreceived * len(m)

  errors = []

  if PRINT_STATISTICS:
    print
    print "-" * 80
    print "UDP Traffic Statistics"
    print "-" * 80

    for sender, receiver in connection_dict:
      addr_dict = connection_dict[(sender, receiver)]

      if not addr_dict['sent']:
        continue

      if isinstance(sender, tuple):
        sender_str = format_addr(sender[0], sender[1])
      else:
        sender_str = "trace " + sender
      receiver_str = format_addr(receiver[0], receiver[1])

      print "Traffic from", sender_str, "to", receiver_str

      print " *",
      print addr_dict['sent'], "datagrams sent,",
      print addr_dict['sent'] - addr_dict['lost'], "datagrams received,",
      print addr_dict['lost'], "datagrams lost",
      if addr_dict['lost']:
        print "(%.2f%%)" % (100.0 * addr_dict['lost'] / addr_dict['sent']),
      print

      print " *",
      print addr_dict['bytes_sent'], "bytes sent,",
      print addr_dict['bytes_sent'] - addr_dict['bytes_lost'], "bytes received,",
      print addr_dict['bytes_lost'], "bytes lost",
      if addr_dict['bytes_lost']:
        print "(%.2f%%)" % (100.0 * addr_dict['bytes_lost'] / addr_dict['bytes_sent']),
      print

      if addr_dict['lost'] == addr_dict['sent']:
        errors.append("[Possible Network Misbehavior] All " + str(addr_dict['sent']) +
            " datagrams sent from " + sender_str + " to " + receiver_str + " were lost")

  return errors


def print_model_state():
  if PRINT_MODEL_STATE:
    print
    print "-" * 80
    print "Final Model State"
    print "-" * 80
    print "tcp_tuples:"
    for t in model.tcp_tuples:
      print "  ", t

    print
    print "udp_tuples:"
    for t in model.udp_tuples:
      print "  ", t

    print
    print "sockets:"
    for socket in model.sockets:
      print "  ",
      if socket in model.active_sockets:
        print "[ACTIVE]",
      print str(socket) + ":", model.sockets[socket]

    print
    print "pending_connections:", model.pending_connections
    print "poll_timeout:", list(model.poll_timeout)
